<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>#FormatEditor
##Allows you to edit how your commands are formatted

### UI
There are things that you can add:
[Text] [Optional Text] [Regex Text]
[+ Namespace]

There is also a textbox where you can type to test out your command
[  Type Here   ] [Test]


To test your command, just type in the textbox and what it will be will appear above
For example, if you made unixlike commands, you could type `trm echo --text testing`
and above that would appear `[trm, echo]{text: "testing", }`
that would mean trm.echo{text: "Testing"} in normal command speak
This shows you how the command will parse once you've applied it

## Using the program
In formateditor there are texts and markers
when you click on [+ Namespace] it will add a "namespace marker"
A namespace marker shows where the namespace in your command starts
In the default command format, it's [namespace].[command]{[argument]: [value], [argument]: [value]}
A text shows text that must be typed for the command to work
For example, in the default command inbetween [namespace] and [command] you must type a `.`

Let's try this out:
Add a [+ Namespace] and then a [Text], then add a [Command]
If you're styling it like the default commands, for the text you would put a `.`
Otherwise, put some text there to seperate the namespace from the command like `:`
You can type spaces and although they're invisible, they will still work
For example "` : `" would mean you have to type `namespace : command`

Try the command out, in the [   Type Here   ] box, type `test.command` or however you formatted it
Above should appear `[test, command]{}` if you typed it right, otherwise there will be a syntax error

Now let's allow arguments in our command
Following the default command style, the user can type a space if they want to before the `{`
To do this, add an [Optional Text] and put a space in it to let the user type the space if they want to
Then add a [Text] and put the `{` in it to require a `{`

If you did it right, after your command you should be able to type `{` and "` {`" and neither should
 give a syntax error. However, if you type something other than ` ` or `{` it should syntax error.
If you type just a space after the command, it won't syntax error yet, however in the future there may
 be more strict command checking.

Now we can get to adding our arguments
Following the standard syntax again, it goes like
`{[argument]:{optinal space} [value],{optional space}[argument]:{optional space}[value]...}`
In FormatEditor, you show how it will look for the first two arguments.
If you add that, it will allow you to type commands just like normal ones.

When you test this, you may notice that you can put "quotes" arround your values like normal.
This is to allow things like spaces in your values if it's not just solid text.

You can press `save` to save this format to a `.cf` file, and then `apply` to use this in your terminal

If it ever turns out there is a bug with your cf after you've applied it, just type
 `stop theme` (lowercase, space required) into your terminal and the standard command parser will be used.
 
 ## Examples
 
 I would put `.cf` files I've made here like `unixlike.cf` but I can't be bothered right now
 So instead, there are no examples yet.
</value>
  </data>
</root>